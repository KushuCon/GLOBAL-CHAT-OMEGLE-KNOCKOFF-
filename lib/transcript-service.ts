interface TranscriptOptions {
  includeTranslations: boolean
  format: "text" | "json" | "csv"
  language?: string
}

interface ChatTranscript {
  chatInfo: {
    code: string
    exportedAt: string
    exportedBy: string
    totalMessages: number
    participants: Array<{
      username: string
      language: string
      isCurrentUser: boolean
    }>
  }
  messages: Array<{
    id: string
    username: string
    userLanguage: string
    timestamp: string
    originalText: string
    translations: Record<string, string>
    isOwn: boolean
  }>
}

export class TranscriptService {
  static generateTextTranscript(
    messages: any[],
    users: any[],
    chatData: any,
    options: TranscriptOptions = { includeTranslations: true, format: "text" },
  ): string {
    const now = new Date()
    const chatDuration =
      messages.length > 0 ? Math.round((now.getTime() - messages[0].timestamp.getTime()) / (1000 * 60)) : 0

    const header = [
      "=".repeat(60),
      "GLOBALCHAT CONVERSATION TRANSCRIPT",
      "=".repeat(60),
      "",
      `Chat Room Code: ${chatData.code}`,
      `Generated: ${now.toLocaleString()}`,
      `Duration: ${chatDuration} minutes`,
      `Total Messages: ${messages.length}`,
      "",
      "PARTICIPANTS:",
      "-".repeat(20),
      ...users.map(
        (user) =>
          `‚Ä¢ ${user.username} (${user.language.toUpperCase()}) ${user.username === chatData.username ? "(You)" : ""}`,
      ),
      "",
      "CONVERSATION:",
      "-".repeat(20),
      "",
    ]

    const messageLines = messages.map((msg, index) => {
      const userTranslation = options.language
        ? msg.translations[options.language] || msg.originalText
        : msg.translations[chatData.language] || msg.originalText

      const showTranslation =
        options.includeTranslations &&
        msg.userLanguage !== (options.language || chatData.language) &&
        userTranslation !== msg.originalText

      const lines = [
        `[${msg.timestamp.toLocaleString()}] ${msg.username} (${msg.userLanguage.toUpperCase()}):`,
        `${msg.originalText}`,
      ]

      if (showTranslation) {
        lines.push(`üìù Translation (${(options.language || chatData.language).toUpperCase()}): ${userTranslation}`)
      }

      if (index < messages.length - 1) {
        lines.push("")
      }

      return lines.join("\n")
    })

    const footer = [
      "",
      "=".repeat(60),
      "End of transcript",
      "Generated by GlobalChat - Connect Across Languages",
      "=".repeat(60),
    ]

    return [...header, ...messageLines, ...footer].join("\n")
  }

  static generateJSONTranscript(messages: any[], users: any[], chatData: any): ChatTranscript {
    return {
      chatInfo: {
        code: chatData.code,
        exportedAt: new Date().toISOString(),
        exportedBy: chatData.username,
        totalMessages: messages.length,
        participants: users.map((user) => ({
          username: user.username,
          language: user.language,
          isCurrentUser: user.username === chatData.username,
        })),
      },
      messages: messages.map((msg) => ({
        id: msg.id,
        username: msg.username,
        userLanguage: msg.userLanguage,
        timestamp: msg.timestamp.toISOString(),
        originalText: msg.originalText,
        translations: msg.translations,
        isOwn: msg.isOwn,
      })),
    }
  }

  static generateCSVTranscript(messages: any[], users: any[], chatData: any, targetLanguage: string): string {
    const headers = [
      "Timestamp",
      "Username",
      "User Language",
      "Original Text",
      `Translation (${targetLanguage.toUpperCase()})`,
      "Is Own Message",
    ]

    const rows = messages.map((msg) => {
      const translation = msg.translations[targetLanguage] || msg.originalText
      return [
        msg.timestamp.toISOString(),
        msg.username,
        msg.userLanguage,
        `"${msg.originalText.replace(/"/g, '""')}"`,
        `"${translation.replace(/"/g, '""')}"`,
        msg.isOwn.toString(),
      ]
    })

    return [headers.join(","), ...rows.map((row) => row.join(","))].join("\n")
  }

  static downloadFile(content: string, filename: string, mimeType = "text/plain") {
    const blob = new Blob([content], { type: `${mimeType};charset=utf-8` })
    const url = URL.createObjectURL(blob)
    const a = document.createElement("a")
    a.href = url
    a.download = filename
    document.body.appendChild(a)
    a.click()
    document.body.removeChild(a)
    URL.revokeObjectURL(url)
  }
}
